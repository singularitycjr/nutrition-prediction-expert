# WebSocket

## 简介

WebSocket是基于TCP的一种新的**网络协议**，实现了**浏览器**与**服务器**之间的全双工通信。

几个客户端之间通过服务器转发消息实现通信：

<img src="任喆轩.assets\websocket网络结构.png" style="zoom: 80%;" />



## 项目相关需求和实现方案

在本项目中，需要实现医生端和患者端消息的传递，可以使用以下工作流：

以医生添加一个患者之后通知该患者为例（仅列出与消息通知有关的部分）：

**（个人建议使用第一种方法）**

**方法一（后端调用WebSocket服务）：**

1. 医生端后端在完成了添加患者服务后调用WebSocket服务端的发送消息方法
2. WebSocket服务端向患者端前端发送消息
3. 患者端前端收到消息后展示信息并提醒

**方法二（前端调用WebSocket服务）：**

1. 医生端前端点击添加患者后，调用后端添加患者服务接口，完成后向WebSocket服务端发送消息，内容包含添加的患者的信息（根据需要来定）和要传递的消息
2. WebSocket服务端接受到消息后向患者端前端发送消息
3. 患者端前端收到消息后展示信息并提醒



## WebSocket相关说明和实现

实现上面的功能，需要在前端和后端都有相关的实现，发送的数据约定为 JSON 格式。

具体而言，需要实现以下方法：

1. **创建WebSocket连接**
2. **OnOpen()方法：**创建WebSocket连接后的回调函数
3. **OnClose()方法：**断开WebSocket连接后的回调函数
4. **OnMessage()方法：**收到该连接另一端发送过来的消息后的回调函数
5. **OnError()方法：**出现异常时的回调函数
6. **其他辅助功能的函数**



### 前端

目前主流浏览器都支持WebSocket协议，可以直接创建WebSocket，以下是一个示例：

```JavaScript
	//判断当前浏览器是否支持WebSocket
    if('WebSocket' in window){
        //连接WebSocket节点
        websocket = new WebSocket("ws://localhost:8080/ws/"+clientId);
        //上面的地址应该为服务端地址
        //clientId在本示例中是一个随机数，可以替换为用户id等，目的是区分各个连接的客户端
    }
    else{
        alert('Not support websocket')
    }

    //连接发生错误的回调方法
    websocket.onerror = function(){
        setMessageInnerHTML("error");
    };

    //连接成功建立的回调方法
    websocket.onopen = function(){
        setMessageInnerHTML("连接成功");
    }

    //接收到消息的回调方法
    websocket.onmessage = function(event){
        setMessageInnerHTML(event.data);//event.data中是另一端发送过来的内容
    }

    //连接关闭的回调方法
    websocket.onclose = function(){
        setMessageInnerHTML("close");
    }

	//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
    window.onbeforeunload = function(){
        websocket.close();
    }

    //将消息显示在网页上
    function setMessageInnerHTML(innerHTML){
        document.getElementById('message').innerHTML += innerHTML + '<br/>';
    }

    //发送消息
    function send(){
        var message = document.getElementById('text').value;//此处是要发送的消息
        websocket.send(message);//发送给服务器
    }
	
	//关闭连接
    function closeWebSocket() {
        websocket.close();
    }

```



### 后端

添加了对应的WebSocket依赖，完成了对应的配置类后，主要是实现下面的内容：

**（已经在项目中实现，目前可以支持消息的接受和发送，但是具体内容需要根据需要修改）**

```Java
@ServerEndpoint("/ws/{userId}")//定义服务的url，完整的为 ws://ip:port/ws/{userId}
@Component
@Slf4j
public class MessageServer {
    //存储目前与服务器建立了连接的会话
    private static final Map<String,Session> onlineUsers = new ConcurrentHashMap<>();

    /**
     * 连接建立成功调用的方法
     */
    @OnOpen
    public void onOpen(Session session, @PathParam("userId") String userId) {
        onlineUsers.put(userId, session);//将该会话添加到map中
        System.out.println("New connection: " + session.getId() + " userId: " + userId);
    }

    /**
     * 连接关闭调用的方法
     */
    @OnClose
    public void onClose(@PathParam("userId") String userId) {
        onlineUsers.remove(userId);//将会话删除
        System.out.println("Connection closed:  userId: " + userId);
    }

    /**
     * 收到客户端消息后调用的方法
     *
     * @ Param message 客户端发送过来的消息
     */
    @OnMessage
    public void onMessage(String message, @PathParam("userId") String userId) throws Exception {
        System.out.println("Message from " + userId + ": " + message);
        //下方是具体功能逻辑的实现
        //注释的代码中是一个发送消息的示例
        //其中Messsage定义如下：
        //private String fromUserId;
    	//private String toUserId;
    	//private String message;
        //从接受到的json中解析出内容，并向目标客户端发送消息
        
//        Message messageObj = JSON.parseObject(message, Message.class);
//        String toUserId = messageObj.getToUserId();
//        String msg = messageObj.getMessage();
//        sendMessageToUser(userId, toUserId, msg);
        
        //测试能否发送消息
        sendToAllClient(message);
    }

    //核心功能函数，向某个用户发送消息，具体实现可以根据需求修改
    private void sendMessageToUser(String fromUserId, String toUserId, String message) throws IOException {
        Session session = onlineUsers.get(toUserId);
        //下面的代码是对某个客户端发送消息，MessageUtils是自定义的一个构造JSON字符串的方法
        session.getBasicRemote().sendText(MessageUtils.getMessage(toUserId, fromUserId, message));
    }

    public void sendToAllClient(String message) {
        Collection<Session> sessions = onlineUsers.values();
        for (Session session : sessions) {
            try {
                //服务器向客户端发送消息
                session.getBasicRemote().sendText(message);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    @OnError
    public void onError(Throwable throwable) {
        throwable.printStackTrace();
    }
}
```



